<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Quest 3 AR - è°ƒè¯•æ•‘æ´ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: yellow; pointer-events: none; z-index: 100;
            text-shadow: 2px 2px 2px #000; font-size: 1.2rem;
        }
    </style>
</head>
<body>

    <div id="info">
        AR è°ƒè¯•ç‰ˆ<br>
        <span id="status" style="color:white; font-size:0.8rem">æ‰¾ä¸åˆ°ç”»é¢ï¼Ÿè¯·æ‰£ä¸€ä¸‹å³æ‰‹æ‰³æœºï¼</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- ğŸ”§ é…ç½®åŒº ---
        const CONFIG = {
            // è¯·åœ¨è¿™é‡Œæ¢ä¸Šä½ è‡ªå·±çš„å›¾ï¼å¦‚æœé“¾æ¥åäº†ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ç”¨çº¯è‰²å—ä»£æ›¿
            renImage: 'https://picsum.photos/id/237/400/600', 
            yiImage: 'https://picsum.photos/id/104/400/600',   
            
            particleSize: 3.0,
            threshold: 4, 
            dissolveSpeed: 0.03,
            recoverSpeed: 0.05
        };

        let scene, camera, renderer;
        let groupContainer, yiParticles, debugBox;
        let handRight, handLeft;
        let dissolveProgress = 0;
        let isHandOpen = false;
        let controllerRight; // å³æ‰‹æ§åˆ¶å™¨

        const statusText = document.getElementById('status');

        init();

        function init() {
            // 1. åœºæ™¯
            scene = new THREE.Scene();

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 2);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. AR æŒ‰é’®
            const button = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['hand-tracking', 'dom-overlay'],
                domOverlay: { root: document.body }
            });
            document.body.appendChild(button);

            // 5. æ§åˆ¶å™¨ (ç”¨äºâ€œå¬å”¤â€åŠŸèƒ½)
            controllerRight = renderer.xr.getController(0);
            controllerRight.addEventListener('select', teleportToObject); // æ‰£æ‰³æœºè§¦å‘
            scene.add(controllerRight);

            setupHands();

            // 6. æ·»åŠ ä¸€ä¸ªâ€œçº¢è‰²ä¿¡æ ‡â€ (Debug Box)
            // æ— è®ºå›¾ç‰‡æ˜¯å¦åŠ è½½ï¼Œè¿™ä¸ªçº¢ç›’å­éƒ½å¿…é¡»å‡ºç°ï¼
            createDebugContent();

            // 7. åŠ è½½èµ„æº (å¸¦å®¹é”™ä¿æŠ¤)
            loadResourcesSafe();

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(render);
        }

        // --- ğŸš€ æ ¸å¿ƒåŠŸèƒ½ï¼šå¬å”¤æœ¯ ---
        function teleportToObject() {
            if (!groupContainer) return;
            
            // æŠŠç‰©ä½“ç¬é—´ç§»åŠ¨åˆ°ä½ çœ¼å‰ 0.5 ç±³å¤„
            // è·å–å¤´éƒ¨ä½ç½®
            const playerPos = new THREE.Vector3();
            const playerDir = new THREE.Vector3();
            camera.getWorldPosition(playerPos);
            camera.getWorldDirection(playerDir);

            // è®¡ç®—ç›®æ ‡ä½ç½®ï¼šå¤´çš„ä½ç½® + å‰æ–¹ 0.5ç±³
            // æ³¨æ„ï¼šåœ¨ AR æ¨¡å¼ä¸‹ï¼Œy è½´å¯èƒ½éœ€è¦å¾®è°ƒï¼Œè¿™é‡Œç›´æ¥è®¾åœ¨çœ¼å‰
            playerDir.multiplyScalar(0.5);
            const targetPos = playerPos.add(playerDir);
            
            // ç¨å¾®é™ä½ä¸€ç‚¹é«˜åº¦ï¼Œè®©ä½ ä¿¯è§†å®ƒ
            targetPos.y -= 0.1; 

            groupContainer.position.copy(targetPos);
            groupContainer.lookAt(camera.position); // è®©ç”»å¯¹ç€ä½ 
            
            statusText.innerText = "å·²å¬å”¤å…¨æ¯å›¾åˆ°çœ¼å‰ï¼";
        }

        function createDebugContent() {
            groupContainer = new THREE.Group();
            groupContainer.position.set(0, 1.5, -0.5); // é»˜è®¤æ”¾åœ¨å‰æ–¹
            groupContainer.scale.set(0.002, 0.002, 0.002);
            scene.add(groupContainer);

            // è¿™æ˜¯ä¸€ä¸ªçº¢è‰²çš„æ—‹è½¬æ–¹å—ï¼Œç”¨æ¥è¯æ˜ç¨‹åºæ²¡æ­»
            const geo = new THREE.BoxGeometry(100, 100, 100);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            debugBox = new THREE.Mesh(geo, mat);
            debugBox.position.x = 200; // æ”¾åœ¨ç”»çš„å³è¾¹
            groupContainer.add(debugBox);
        }

        // --- å®‰å…¨åŠ è½½èµ„æº (å³ä½¿404ä¹Ÿèƒ½è·‘) ---
        async function loadResourcesSafe() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');

            // è¾…åŠ©å‡½æ•°ï¼šå°è¯•åŠ è½½ï¼Œå¤±è´¥åˆ™è¿”å›ä¸€ä¸ªçº¯è‰²çº¹ç†
            const safeLoad = (url, fallbackColor) => {
                return new Promise(resolve => {
                    loader.load(
                        url, 
                        (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            resolve(tex);
                        },
                        undefined, 
                        (err) => {
                            console.warn(`å›¾ç‰‡ ${url} åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨è‰²å—`);
                            statusText.innerText = "å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œå·²ä½¿ç”¨å¤‡ç”¨è‰²å—";
                            resolve(createPlaceholderTexture(fallbackColor));
                        }
                    );
                });
            };

            const texRen = await safeLoad(CONFIG.renImage, '#333333'); // å¤±è´¥å˜æ·±ç°
            const texYi = await safeLoad(CONFIG.yiImage, '#00ff88');   // å¤±è´¥å˜äº®ç»¿

            createHologram(texRen, texYi);
        }

        // åˆ›å»ºå¤‡ç”¨çš„çº¯è‰²å›¾ç‰‡
        function createPlaceholderTexture(colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorStr;
            ctx.fillRect(0,0,64,64);
            // ç”»ä¸ª X
            ctx.strokeStyle = 'white';
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(64,64); ctx.moveTo(64,0); ctx.lineTo(0,64); ctx.stroke();
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createHologram(texRen, texYi) {
            // ç§»é™¤æ—§çš„ï¼ˆå¦‚æœæœ‰ï¼‰
            const oldMesh = groupContainer.getObjectByName("mainMesh");
            if(oldMesh) groupContainer.remove(oldMesh);
            const oldParticles = groupContainer.getObjectByName("particles");
            if(oldParticles) groupContainer.remove(oldParticles);

            const aspect = texYi.image.width / texYi.image.height;
            const h = 250; 
            const w = h * aspect;

            // 1. èƒŒæ™¯
            const geoRen = new THREE.PlaneGeometry(w, h);
            const matRen = new THREE.MeshBasicMaterial({ map: texRen, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const meshRen = new THREE.Mesh(geoRen, matRen);
            meshRen.name = "mainMesh";
            meshRen.position.z = -5;
            groupContainer.add(meshRen);

            // 2. ç²’å­
            const imgData = getImageData(texYi.image);
            const { p, c, r } = generateParticles(imgData, w, h);
            
            const geoYi = new THREE.BufferGeometry();
            geoYi.setAttribute('position', new THREE.Float32BufferAttribute(p, 3));
            geoYi.setAttribute('color', new THREE.Float32BufferAttribute(c, 3));
            geoYi.setAttribute('aRandom', new THREE.Float32BufferAttribute(r, 3));

            const matYi = new THREE.ShaderMaterial({
                uniforms: { uProgress: { value: 0.0 }, uSize: { value: CONFIG.particleSize } },
                vertexShader: `
                    uniform float uProgress; uniform float uSize;
                    attribute vec3 color; attribute vec3 aRandom;
                    varying vec3 vColor; varying float vAlpha;
                    void main() {
                        vColor = color; vec3 pos = position;
                        float d = uProgress * 150.0;
                        pos += aRandom * d; 
                        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mv;
                        gl_PointSize = uSize * (50.0 / -mv.z) * (1.0 - uProgress);
                        vAlpha = 1.0 - uProgress;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor; varying float vAlpha;
                    void main() {
                        if (vAlpha < 0.05) discard;
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.NormalBlending
            });

            yiParticles = new THREE.Points(geoYi, matYi);
            yiParticles.name = "particles";
            groupContainer.add(yiParticles);
            
            statusText.innerText = "å…¨æ¯å›¾å·²ç”Ÿæˆï¼å¦‚æœåœ¨èº«åè¯·æ‰£æ‰³æœºã€‚";
        }

        // --- æ‰‹åŠ¿ä¸æ¸²æŸ“ ---
        function setupHands() {
            handRight = renderer.xr.getHand(0); scene.add(handRight);
            handLeft = renderer.xr.getHand(1); scene.add(handLeft);
        }

        function checkHand(hand) {
            if(!hand || !hand.joints || !hand.joints['wrist']) return false;
            const d = hand.joints['wrist'].position.distanceTo(hand.joints['index-finger-tip'].position);
            if(d > 0.12) isHandOpen = true;
            else if(d < 0.08) isHandOpen = false;
        }

        function render() {
            if(debugBox) debugBox.rotation.y += 0.05; // çº¢ç›’å­è‡ªè½¬è¯æ˜è¿˜æ²¡æ­»æœº
            
            if(handRight) checkHand(handRight);
            if(handLeft) checkHand(handLeft);

            if(isHandOpen) dissolveProgress += CONFIG.dissolveSpeed;
            else dissolveProgress -= CONFIG.recoverSpeed;
            dissolveProgress = Math.max(0, Math.min(1, dissolveProgress));

            if(yiParticles) {
                yiParticles.material.uniforms.uProgress.value = dissolveProgress;
            }

            renderer.render(scene, camera);
        }

        // --- å·¥å…· ---
        function getImageData(img) {
            const c = document.createElement('canvas'); c.width = img.width; c.height = img.height;
            const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0);
            return ctx.getImageData(0, 0, img.width, img.height);
        }
        function generateParticles(data, w, h) {
            const p=[], c=[], r=[]; const s=CONFIG.threshold;
            for(let y=0; y<data.height; y+=s) for(let x=0; x<data.width; x+=s) {
                const i=(y*data.width+x)*4;
                if(data.data[i+3]>50) {
                    p.push((x/data.width-0.5)*w, -(y/data.height-0.5)*h, 0);
                    c.push(data.data[i]/255, data.data[i+1]/255, data.data[i+2]/255);
                    r.push((Math.random()-.5)*2, (Math.random()-.5)*2, Math.random());
                }
            }
            return { p: new Float32Array(p), c: new Float32Array(c), r: new Float32Array(r) };
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
