<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Quest 3 透视粒子 (修复版)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #111; /* 网页预览时是黑的，进AR后会消失 */
            font-family: sans-serif;
        }
        #info {
            position: absolute; 
            top: 20px; 
            width: 100%; 
            text-align: center; 
            color: #ccc; 
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="info">AR 粒子修复版 - 请点击底部 AR 按钮</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // 关键修改：引入 ARButton 而不是 VRButton
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- ⚙️ 配置 ---
        const CONFIG = {
            // 背景图
            renImage: 'https://picsum.photos/id/237/400/600', 
            // 粒子图
            yiImage: 'https://picsum.photos/id/104/400/600',   
            
            // 关键调整：VR里 2.5 左右比较清晰，太大容易糊
            particleSize: 2.5,   
            threshold: 4,        
            dissolveSpeed: 0.04, 
            recoverSpeed: 0.06   
        };

        let scene, camera, renderer;
        let yiParticles, hologramGroup;
        let handRight, handLeft;
        let dissolveProgress = 0;
        let isHandOpen = false;

        init();

        function init() {
            // 1. 场景
            scene = new THREE.Scene();
            // ⚠️ 绝对不要设置 scene.background，否则会遮挡透视摄像头！
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 2);

            // 2. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 3. 关键修改：使用 ARButton 开启透视模式
            // sessionInit 必须请求 'immersive-ar'
            const button = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay', 'hand-tracking'], // 请求手势追踪
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(button);

            // 4. 手势追踪
            setupHands();

            // 5. 监听 AR 启动
            renderer.xr.addEventListener('sessionstart', () => {
                // AR 启动后，把全息图放到面前 0.5 米
                if(hologramGroup) {
                    hologramGroup.position.set(0, 1.3, -0.5);
                    hologramGroup.scale.set(0.0015, 0.0015, 0.0015);
                }
            });

            // 6. 加载资源
            loadResources();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            renderer.setAnimationLoop(render);
        }

        function setupHands() {
            handRight = renderer.xr.getHand(0);
            scene.add(handRight);
            handLeft = renderer.xr.getHand(1);
            scene.add(handLeft);
        }

        async function loadResources() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            
            const load = url => new Promise(resolve => loader.load(url, tex => {
                tex.colorSpace = THREE.SRGBColorSpace;
                resolve(tex);
            }));

            try {
                const [texRen, texYi] = await Promise.all([load(CONFIG.renImage), load(CONFIG.yiImage)]);
                createHologram(texRen, texYi);
            } catch (e) {
                console.error("图片加载失败", e);
            }
        }

        function createHologram(texRen, texYi) {
            hologramGroup = new THREE.Group();
            scene.add(hologramGroup);
            
            // 默认预览位置
            hologramGroup.position.set(0, 1.5, -1);
            hologramGroup.scale.set(0.002, 0.002, 0.002);

            const aspect = texYi.image.width / texYi.image.height;
            const w = 300 * aspect;
            const h = 300;

            // 背景板
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                new THREE.MeshBasicMaterial({ 
                    map: texRen, 
                    transparent: true, 
                    opacity: 0.4, // 半透明背景
                    side: THREE.DoubleSide 
                })
            );
            plane.position.z = -2;
            hologramGroup.add(plane);

            // 粒子系统
            const imgData = getImageData(texYi.image);
            const { pos, col, rnd } = generateParticles(imgData, w, h);

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            geo.setAttribute('aRandom', new THREE.Float32BufferAttribute(rnd, 3));

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uProgress: { value: 0.0 },
                    uSize: { value: CONFIG.particleSize }
                },
                vertexShader: `
                    uniform float uProgress;
                    uniform float uSize;
                    attribute vec3 color;
                    attribute vec3 aRandom;
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        vColor = color;
                        vec3 p = position;
                        
                        // 炸裂效果
                        float dist = uProgress * 200.0;
                        p.x += aRandom.x * dist;
                        p.y += aRandom.y * dist + uProgress * 50.0;
                        p.z += aRandom.z * dist * 3.0;

                        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // 粒子大小随距离衰减
                        gl_PointSize = uSize * (300.0 / -mvPosition.z) * (1.0 - uProgress * 0.5);
                        vAlpha = 1.0 - uProgress;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        if (vAlpha < 0.05) discard;
                        vec2 uv = gl_PointCoord.xy - 0.5;
                        if (length(uv) > 0.5) discard;
                        gl_FragColor = vec4(vColor, vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                // 关键修复：改为 NormalBlending，防止变白！
                blending: THREE.NormalBlending 
            });

            yiParticles = new THREE.Points(geo, mat);
            hologramGroup.add(yiParticles);
        }

        // --- 手势与动画 ---
        function checkHand(hand) {
            if (!hand || !hand.joints || !hand.joints['wrist']) return false;
            const dist = hand.joints['wrist'].position.distanceTo(hand.joints['index-finger-tip'].position);
            
            // 阈值判定
            if (dist > 0.12) isHandOpen = true;
            else if (dist < 0.08) isHandOpen = false;
        }

        function render() {
            if (handRight) checkHand(handRight);
            if (handLeft) checkHand(handLeft);

            if (isHandOpen) dissolveProgress += CONFIG.dissolveSpeed;
            else dissolveProgress -= CONFIG.recoverSpeed;
            dissolveProgress = Math.max(0, Math.min(1, dissolveProgress));

            if (yiParticles) {
                yiParticles.material.uniforms.uProgress.value = dissolveProgress;
                hologramGroup.rotation.y = Math.sin(Date.now() * 0.0005) * 0.15; // 缓慢自转
            }

            renderer.render(scene, camera);
        }

        // --- 工具 ---
        function getImageData(img) {
            const c = document.createElement('canvas');
            c.width = img.width; c.height = img.height;
            const ctx = c.getContext('2d');
            ctx.drawImage(img, 0, 0);
            return ctx.getImageData(0, 0, img.width, img.height);
        }

        function generateParticles(data, w, h) {
            const pos = [], col = [], rnd = [];
            for (let y = 0; y < data.height; y += CONFIG.threshold) {
                for (let x = 0; x < data.width; x += CONFIG.threshold) {
                    const i = (y * data.width + x) * 4;
                    if (data.data[i + 3] > 50) {
                        pos.push((x / data.width - 0.5) * w, -(y / data.height - 0.5) * h, 0);
                        col.push(data.data[i] / 255, data.data[i+1] / 255, data.data[i+2] / 255);
                        rnd.push((Math.random()-0.5)*2, (Math.random()-0.5)*2, Math.random());
                    }
                }
            }
            return { pos: new Float32Array(pos), col: new Float32Array(col), rnd: new Float32Array(rnd) };
        }
    </script>
</body>
</html>
